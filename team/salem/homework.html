<!DOCTYPE html>
<html>
<head>
<title>
CSC-317 Notes
</title>
</head>
<body>
<button onclick = "oc(822)">8.2.2 Notes</button>
<button onclick = "oc(823)">8.2.3 Notes</button>
<button onclick = "oc(824)">8.2.4 Notes</button>
<button onclick = "oc(825)">8.2.5 Notes</button>
<button onclick = "oc(826)">8.2.6 Notes</button>
<div id = "822" style = "display:none">
    <h1>8.2.2 Notes</h1>
	<ul>
		<li>1961 to 1972</li>
			<ul>
				<li>Leonard Kleinrock</li>
				<ul>
					<li>The first published work on packet-switching techniques</li>
					<li>He used queuing theory to demonstrated the effectiveness of the packet-switching approach for bursty traffic sources.</li>
				</ul>
				<li>Paul Baran</li>
				<ul>
					<li>worked at the National Physical Laboratory in England</li>
					<li>investigated the use of packet switching for secure voice over military networks</li>
				</ul>
			</ul>
		<li>1972 to 1980</li>
		<ul>
			<li>Norman Abramson</li>
				<ul>
					<li>developing ALOHAnet, a packet-based radio network that allowed multiple remote sites on the Hawaiian Islands to communicate with each other</li>
					<li>The program was the first multiple-access protocol, allowing geographically distributed users to share a single broadcast communication medium (a radio frequency).</li>
				</ul>
			<li>Vinton Cerf and Robert Kahn</li>
				<ul>
					<li>They worked on interconnecting networks (under the sponsorship of the Defense Advanced Research Projects Agency (DARPA)), in essence creating a network of networks</li>
					<li><a href = "https://en.wikipedia.org/wiki/Vint_Cerf">About Vinton Cerf</a></li>
					<li><a href = "https://en.wikipedia.org/wiki/Bob_Kahn">About Rovert Kahn</a></li>
				</ul>
			<li>Metcalfe and Boggs</li>
			<ul>
				<li>built on Abramson’s multiple-access protocol work when they developed the Ethernet protocol</li>
			</ul>
		</ul>
		<li>1980 to 1990</li>
		<ul>
			<li>Minitel project</li>
			<ul>
				<li>In the early 1980s the French launched the Minitel project.</li>
				<li>Used consisted of a public packet-switched network, Minitel servers, and inexpensive terminals with built-in low-speed modems.</li>
				<li>Succeeded in 1984</li>
				<li>Included free sites—such as a telephone directory site—as well as private sites, which collected a usage-based fee from each user.</li>
				<li>Was in a large proportion of French homes 10 years before most Americans had ever heard of the Internet.</li>
			</ul>
		</ul>
		<li>1990s</li>
		<ul>
			<li>Tim Berners-Lee</li>
				<li>Worked at CERN</li>
				<li>developed initial versions of HTML, HTTP, a Web server, and a browser based on ideas originating in earlier work on hypertext from</li>
			<ul>
				<li>Vannevar Bush (1940s)</li>
				<li>Ted Nelson (1960s)</li>
			</ul>
		</ul>
	</ul>
<hr style="height:3px;border:none;color:#333;background-color:#333;">
</div>


<div id = "823" style  ="display:none">
	<h1>8.2.3 Notes</h1>
		<ul>
			<li><h2>P2P(Peer To Peer)</h2></li>
			<li>future challenges:
			<ul>
				<li>ISP Friendly: If switching from downstream to upstream will change from server to redsidential ISP, so there will be significant pressure on ISPs.</li>
				<li>Security: because P2P is so open and highly distributed, so securing it will be difficult.</li>
				<li>Incentives: volunteers supply the bandwidth, storyage, and computation resources to application, so their might be a challenge in incentive design.</li>
			</ul>


			<li><h2>process</h2></li>
			<ul>
				<li>can be thought of as a program that is running within an end system.</li>
			</ul>


			<li><h2>client and server</h2></li>
			<ul>
				<li>browser is a client process.</li>
				<li>Web server is a server process.</li>
			</ul>


			<li><h2>socket</h2></li>
			<ul>
				<li>When a process wants to send a message to antoher process on another host, it shoves the message out its socket.</li>
			</ul>


			<li><h2>IP address</h2></li>
			<ul>
				<li>the host identified</li>
			</ul>


			<li><h2>Services along four dimensions:</h2></li>
			<ul>


			<li><h3>Reliable Data Transfer</h3></li>
			<ul>
				<li>a transport-layer protocol can potentially provide to an application is process-to-process reliable data transfer.  However, there is a loss-tolerant applications that may not arrive but that is acceptable.</li>
			</ul>


			<li><h2>Throughput</h2></li>
			<ul>
				<li>rate at which the sending process can deliver bits to the receiving process.</li>
			</ul>


			<li><h2>Timing</h2></li>
			<ul>
				<li>a transport-layer protocol can guarantee that time contraints on data delivery will be achieved.</li>
			</ul>


			<li><h2>Security</h2></li>
			<ul>
				<li>A transport protocol can provide an application with one or more security services.</li>
			</ul>

			</ul>
		</ul>
<hr style="height:3px;border:none;color:#333;background-color:#333;">
		
</div>

<div id = "824" style  ="display:none">
	<h1>8.2.4 Notes</h1>
		<ul>
			<li><h2>SMTP</h2></li>
			<ul>
				<li>Once the SMTP client and server have introduced themselves to each other, the client sends the message. SMTP can count on the reliable data transfer service of TCP to get the message to the server without errors. The client then repeats this process over the same TCP connection if it has other messages to send to the server; otherwise, it instructs TCP to close the connection.
</li>

				<li>SMTP uses persistent connections</li>
			</ul>
			<li><h2>HTTP comparing SMTP</h2></li>
			<ol>
				<li><ul><li>HTTP transfers files (also called objects) from a Web server to a Web client (typically a browser)</li>
				<li>SMTP transfers files (that is, e-mail messages) from one mail server to another mail server.</li></ul></li>
				
				<hr>


				<li><ul><li>HTTP is mostly uses the pull protocol:</li>
					<ul><li>someone loads information on a Web server and users use HTTP to pull the information from the server at their convenience.</li></ul>
				<li>SMTP mostly uses the push protocal:</li>
					<ul><li>the sending mail server pushes the file to the receiving mail server.</li></ul>
				<li>They both use TCP to initialize the connection.</li>
				</ul></li>

				<hr>


				<li><ul><li>SMTP requires each message, including the body of each message, to be in 7-bit ASCII format.  If the message is not in 7-bit ASCII format, then the message has to be encoded into 7-bit ASCII.</li>
				<li>HTTP data does not impose this restriction</li>
				</ul></li>

				<hr>

			<li><ul>
				<li>HTTP encapsulates each object in its own HTTP response message.</li>
				<li>SMTP places all of objects that belongs to the message into one message.</li>
			</li></ul>
			</ol>
		</ul>
<hr style="height:3px;border:none;color:#333;background-color:#333;">
		
</div>



<div id = "825" style  ="display:none">
	<h1>8.2.5 Notes</h1>
		<h2>TCP vs UDP</h2>
		<h3>UDP client</h3>
		<div>from socket import *<br>serverName = &#39hostname&#39<br>serverPort = 12000<br>clientSocket = socket(socket.AF_INET, socket.SOCK_DGRAM)<br>message = raw_input(&#39Input lowercase sentence:&#39)<br>clientSocket.sendto(message,(serverName, serverPort))<br>modifiedMessage, serverAddress = clientSocket.recvfrom(2048)<br>print modifiedMessage<br>clientSocket.close()<br></div>


<div>from socket import *</div>
<ul>
	<li>The socket module forms the basis of all network communications in Python. By
including this line, we will be able to create sockets within our program.</li>

</ul>

<div>serverName = &#39hostname&#39<br>serverPort = 12000<br></div>
<ul>
	<li>The first line sets the string serverName to hostname. Here, we provide a string
containing either the IP address of the server (e.g., &#34128.138.32.126&#34) or the hostname
of the server (e.g., &#34cis.poly.edu&#34). If we use the hostname, then a DNS lookup
will automatically be performed to get the IP address.) The second line sets the integer
variable serverPort to 12000.</li>

</ul>

<div>clientSocket = socket(socket.AF_INET, socket.SOCK_DGRAM)</div>
<ul>
	<li>This line creates the client’s socket, called clientSocket. The first parameter indicates the address family; in particular, AF_INET indicates that the underlying
network is using IPv4.  The second parameter indicates that the socket is of type SOCK_DGRAM, which means it is a UDP socket (rather than a TCP socket). Note that we are not specifying the port number of the client socket when we create it; we are instead letting
the operating system do this for us.</li>

</ul>


<div>message = raw_input(&#39Input lowercase sentence:&#39)</div>
<ul>
	<li>raw_input() is a built-in function in Python. When this command is executed,
the user at the client is prompted with the words “Input data:” The user then uses her
keyboard to input a line, which is put into the variable message. Now that we have
a socket and a message, we will want to send the message through the socket to the
destination host.</li>

</ul>


<div>clientSocket.sendto(message,(serverName, serverPort))</div>
<ul>
	<li>In the above line, the method sendto() attaches the destination address
(serverName, serverPort) to the message and sends the resulting packet into
the process&#39s socket, clientSocket. (As mentioned earlier, the source address is
also attached to the packet, although this is done automatically rather than explicitly
by the code.) Sending a client-to-server message via a UDP socket is that simple!
After sending the packet, the client waits to receive data from the server.</li>

</ul>

<div>modifiedMessage, serverAddress = clientSocket.recvfrom(2048)</div>
<ul>
	<li>With the above line, when a packet arrives from the Internet at the client&#39s socket, the packet&#39s data is put into the variable modifiedMessage and the packet&#39s source address is put into the variable serverAddress. The variable
serverAddress contains both the server&#39s IP address and the server&#39s port
number. The program UDPClient doesn&#39t actually need this server address information,
since it already knows the server address from the outset; but this line of
Python provides the server address nevertheless. The method recvfrom also
takes the buffer size 2048 as input. (This buffer size works for most purposes.)</li>

</ul>

<div>print modifiedMessage</div>
<ul>
	<li>This line prints out modifiedMessage on the user’s display. It should be the original line that the user typed, but now capitalized.</li>

</ul>

<div>clientSocket.close()</div>
<ul>
	<li>This line closes the socket. The process then terminates.</li>

</ul>


<h3>UDP Server</h3>
<div>from socket import *<br>serverPort = 12000<br>serverSocket = socket(AF_INET, SOCK_DGRAM)<br>serverSocket.bind((&#39&#39, serverPort))<br>print &#34The server is ready to receive&#34<br>while 1:<br><ul><li>message, clientAddress = serverSocket.recvfrom(2048)</li><li>modifiedMessage = message.upper()</li><li>serverSocket.sendto(modifiedMessage, clientAddress)</li></ul></div>


<div>serverSocket.bind((&#39&#39, serverPort))</div>
<ul>
	<li>The above line binds (that is, assigns) the port number 12000 to the server’s socket. Thus in UDPServer, the code (written by the application developer) is explicitly assigning a port number to the socket. In this manner, when anyone sends a packet to port 12000 at the IP address of the server, that packet will be directed to this
socket. UDPServer then enters a while loop; the while loop will allow UDPServer
to receive and process packets from clients indefinitely. In the while loop,
UDPServer waits for a packet to arrive.</li>

</ul>

<div>message, clientAddress = serverSocket.recvfrom(2048)</div>
<ul>
	<li>This line of code is similar to what we saw in UDPClient. When a packet arrives at the server&#39s socket, the packet&#39s data is put into the variable message and the packet&#39s source address is put into the variable clientAddress. The variable
clientAddress contains both the client&#39s IP address and the client&#39s port number.
Here, UDPServer will make use of this address information, as it provides a return
address, similar to the return address with ordinary postal mail. With this source
address information, the server now knows to where it should direct its reply.</li>

</ul>

<div>modifiedMessage = message.upper()</div>
<ul>
	<li>This line is the heart of our simple application. It takes the line sent by the client and uses the method upper() to capitalize it.</li>

</ul>

<div>serverSocket.sendto(modifiedMessage, clientAddress)</div>
<ul>
	<li>This last line attaches the client’s address (IP address and port number) to the capitalized message, and sends the resulting packet into the server’s socket. (As mentioned earlier, the server address is also attached to the packet, although this is done automatically rather than explicitly by the code.)</li>

</ul>


<h3>TCP Client</h3>
<div>from socket import *<br>serverName = &#39servername&#39<br>serverPort = 12000<br>clientSocket = socket(AF_INET, SOCK_STREAM)<br>clientSocket.connect((serverName,serverPort))<br>sentence = raw_input(&#39Input lowercase sentence:&#39)<br>clientSocket.send(sentence)<br>modifiedSentence = clientSocket.recv(1024)<br>print &#39From Server:&#39, modifiedSentence<br>clientSocket.close()<br></div>

<div>clientSocket = socket(AF_INET, SOCK_STREAM)</div>
<ul>
	<li>This line creates the client’s socket, called clientSocket. The first parameter again indicates that the underlying network is using IPv4. The second parameter
indicates that the socket is of type SOCK_STREAM, which means it is a TCP socket
(rather than a UDP socket). Note that we are again not specifying the port number of the client socket when we create it; we are instead letting the operating system
do this for us.</li>

</ul>


<div>clientSocket.connect((serverName,serverPort))</div>
<ul>
	<li>Recall that before the client can send data to the server (or vice versa) using a TCP socket, a TCP connection must first be established between the client and server. The above line initiates the TCP connection between the client and server. The
parameter of the connect() method is the address of the server side of the connection.
After this line of code is executed, the three-way handshake is performed
and a TCP connection is established between the client and server.</li>

</ul>

<div>sentence = raw_input(&#39Input lowercase sentence:&#39)</div>
<ul>
	<li>As with UDPClient, the above obtains a sentence from the user. The string sentence continues to gather characters until the user ends the line by typing a carriage return. The next line of code is also very different from UDPClient:</li>

</ul>

<div>clientSocket.send(sentence)</div>
<ul>
	<li>The above line sends the string sentence through the client&#39s socket and into the TCP connection. Note that the program does not explicitly create a packet and attach the destination address to the packet, as was the case with UDP sockets. Instead the client program simply drops the bytes in the string sentence into the TCP connection.
The client then waits to receive bytes from the server.</li>

</ul>

<div>modifiedSentence = clientSocket.recv(2048)</div>
<ul>
	<li>When characters arrive from the server, they get placed into the string modifiedSentence. Characters continue to accumulate in modifiedSentence until the
line ends with a carriage return character. After printing the capitalized sentence, we
close the client’s socket:</li>

</ul>

<div>clientSocket.close()</div>
<ul>
	<li>This last line closes the socket and, hence, closes the TCP connection between the client and the server. It causes TCP in the client to send a TCP message to TCP in the server </li>

</ul>

<h3>TCP Server</h3>

<div>from socket import *<br>serverPort = 12000<br>serverSocket = socket(AF_INET,SOCK_STREAM)<br>serverSocket.bind((&#39&#39,serverPort))<br>serverSocket.listen(1)<br>print &#39The server is ready to receive&#39<br>while 1:<br><ul><li>connectionSocket, addr = serverSocket.accept()</li><li>sentence = connectionSocket.recv(1024)</li><li>capitalizedSentence = sentence.upper()</li><li>connectionSocket.send(capitalizedSentence)</li><li>connectionSocket.close()</li></ul></div>

<div>serverSocket=socket(AF_INET,SOCK_STREAM)</div>
<ul>
	<li>Similar to UDPServer, we associate the server port number, serverPort, with
this socket:</li>

</ul>

<div>serverSocket.bind((&#39&#39,serverPort))</div>
<ul>
	<li>But with TCP, serverSocket will be our welcoming socket. After establishing
this welcoming door, we will wait and listen for some client to knock on the
door:</li>

</ul>

<div>serverSocket.listen(1)</div>
<ul>
	<li>This line has the server listen for TCP connection requests from the client. The
parameter specifies the maximum number of queued connections (at least 1).</li>

</ul>


<div>connectionSocket, addr = serverSocket.accept()</div>
<ul>
	<li>When a client knocks on this door, the program invokes the accept() method for serverSocket, which creates a new socket in the server, called connectionSocket,
dedicated to this particular client. The client and server then complete
the handshaking, creating a TCP connection between the client’s clientSocket
and the server’s connectionSocket. With the TCP connection established, the
client and server can now send bytes to each other over the connection. With TCP, all
bytes sent from one side not are not only guaranteed to arrive at the other side but also
guaranteed arrive in order.</li>

</ul>


<div>connectionSocket.close()</div>
<ul>
	<li>In this program, after sending the modified sentence to the client, we close the connection socket. But since serverSocket remains open, another client can now
knock on the door and send the server a sentence to modify</li>

</ul>


<hr style="height:3px;border:none;color:#333;background-color:#333;">
		
</div>




<!-- This is a nice formate to just copy and paste into your page
			<li> -- This is merely to show how everything would be alined.


			<li><h2></h2></li>
			<ul>
				<li></li>
			</ul>

-->

<!--<div></div>
<ul>
	<li></li>

</ul>

-->



<!-- All of this information is from Computer Networking: Top-Down Approach (w/Access Code) Edition: 6th and other sources -->
<!-- style="height:3px;border:none;color:#333;background-color:#333;" was taken from http://stackoverflow.com/questions/4151743/how-i-change-the-thickness-of-my-hr-tag  and I take no credit!
-->

<div id = "826" style = "display:none">
    <h1>8.2.6 Notes</h1>
<h2>Demultiplexing</h2>
<ul><li>At the receiving end, the transport layer examines these fields to identify the receiving socket and then directs the segment to that socket. This job of delivering the data in a transport&#45layer segment to the correct socket is called demultiplexing.
</li></ul>
<h2>Multiplexing</h2>
<ul><li>The job of gathering data chunks at the source host from different sockets, encapsulating each data chunk with header information (that will later be used in demultiplexing) to create segments, and passing the segments to the network layer is called multiplexing.
</li></ul>
<h2>UDP rather than over TCP</h2>
<ul>
<li><h3>Finer application-level control over what data is sent, and when:</h3></li>
<ul><li>Under UDP, as soon as an application process passes data to UDP, UDP will package the data inside a UDP segment and immediately pass the segment to the network layer. TCP, on the other hand, has a congestion-control mechanism that throttles the transport-layer TCP sender when one or more links between the source and destination hosts become excessively congested. TCP will also continue to resend a segment until the receipt of the segment has been acknowledged by the destination, regardless of how long reliable delivery takes. Since real-time applications often require a minimum sending rate, do not want to overly delay segment transmission, and can tolerate some data loss, TCP's service model is not particularly well matched to these applications' needs. As discussed below, these applications can use UDP and implement, as part of the application, any additional functionality that is needed beyond UDP's no-frills segment-delivery service.</li></ul>
<li><h3>No connection establishment:</h3></li>
<ul><li>As we'll discuss later, TCP uses a three-way handshake before it starts to transfer data. UDP just blasts away without any formal preliminaries. Thus UDP does not introduce any delay to establish a connection. This is probably the principal reason why DNS runs over UDP rather than TCP, DNS would be much slower if it ran over TCP. HTTP uses TCP rather than UDP, since reliability is critical for Web pages with text. But, as we briefly discussed in Section 2.2, the TCP connection-establishment delay in HTTP is an important contributor to the delays associated with downloading Web documents.</li></ul>
<li><h3>No Connection Stat</h3></li>
<ul><li>TCP maintains connection state in the end systems. This connection state includes receive and send buffers, congestion-control parameters, and sequence and acknowledgment number parameters. We will see in Section 3.5 that this state information is needed to implement TCP's reliable data transfer service and to provide congestion control. UDP, on the other hand, does not maintain connection state and does not track any of these parameters. For this reason, a server devoted to a particular application can typically support many more active clients when the application runs over UDP rather than TCP.</li></ul>
<li><h3>Small Packet Header Overhead</h3></li>
<ul><li>The TCP segment has 20 bytes of header overhead in every segment, whereas UDP has only 8 bytes of overhead.</li></ul>
</ul>
<hr style="height:3px;border:none;color:#333;background-color:#333;">
</div>


<script>
function oc(id){
	if(document.getElementById(id).style.display == "none"){
		document.getElementById(id).style.display = "block";
	} else {
		document.getElementById(id).style.display = "none";
	}
}
</script>
</body>
</html>

